/**********************************************************************************************************************
 * Pseudocode for programming project 1 of Data Structures with Java with Professor Berry
 *
 * @note
 *   1. Pseudocode for the 8 queens problem
 *
 * @author mlewis
 * @version Oct 8, 2019
 *********************************************************************************************************************/

/**********************************************************************************************************************
 * A Game is a sequence of choices attempting to solve the 8 Queens problem on a chess board. Each choice consists of a
 * row and column number and is then pushed onto a LinkedStack.
 *
 * The 8 Queens problem postulates that you can place 8 Queens on a chess board, so that no Queen could capture any
 * other.
 *
 * @note
 *  1. Beyond Integer.MAX_VALUE elements, the size method in LinkedStack does not work.

 * @author mlewis
 * @version Oct 16, 2019
 *********************************************************************************************************************/

 public class Game {
     // Invariant of the Game class.
     //  1. The instance variable stack is a LinkedStack.
     //  2. The instance variable success indicates whether or not a solution to the 8 queens problem has been found.
     //  3. The instance variable boardSize indicates how many rows and columns are on the chess board.
     //  4. Stack will have access to a top node and size variables within the LinkedStack.java class.
     private boolean success;
     private int boardSize;
     private LinkedStack<Integer> stack;

     /**
     * Helper method to determine if there is a diagonal conflict. A diagonal conflict indicates that placing a
     * queen at the given row and column combination would result in an invalid board setup.
     * @param row
     *  Indicates the row on the chess board being tested.
     * @param column
     *  Indicates the column on the chess board being tested.
     * @return boolean
     *  A return value of true indicates that placing a queen on this diagonal path does not violate a valid board set
     *  up. A return value of false indicates that a queen cannot be placed in the given location.
     */
     private boolean isDiagonalValid(int row, int column) {
        LOOP from 0 to boardSize
          CALCULATE slope of current row and column relative to previous row and column
          IF slope equals one
            THEN a conflict exists
            RETURN false
          ELSE
            Current row and column is a valid option
            RETURN true
     }

      /**
      * Helper method to determine if there is a horizontal conflict. A horizontal conflict indicates that placing a
      * queen at the given row and column combination would result in an invalid board setup.
      * @param row
      *  Indicates the row on the chess board being tested.
      * @return boolean
      *  A return value of true indicates that placing a queen on this horizontal path does not violate a valid board
      *  set up. A return value of false indicates that a queen cannot be placed in the given location.
      */
     private boolean isHorizontalValid(int row) {
        LOOP from 0 to boardSize
          IF current row equals the row of the previous queen
            THEN a conflict exists
            RETURN false
          ELSE
            Current row is a valid option
            RETURN true
     }

     /**
     * Helper method to determine if there is a column conflict. A column conflict indicates that placing a queen at
     * the given row and column combination would result in an invalid board setup.
     * @param column
     * Indicates the column on the chess board being tested.
     * @return boolean
     *  A return value of true indicates that placing a queen on this column does not violate a valid board set up. A
     *  return value of false indicates that a queen cannot be placed in the given location.
     */
     private boolean isColumnValid(int column) {
        ITERATE over the linked stack
          IF the data at the current node equals the column
            THEN a conflict exists
            RETURN false
          ELSE
            Current column is a valid option
            RETURN true
     }

     /**
     * Helper method used that plays the 8 queens game until a solution is found.
     * @param stack
     *  The stack is a LinkedStack used to store the positions of the queens on the board.
     * @precondition
     *  A chess board has been constructed.
     * @return LinkedStack
     *  A LinkedStack that contains solution to the 8 queens problem
     * @postcondition
     *  A solution to the 8 queens problem has been found
     */
     public LinkedStack<Integer> play() {
        INIT column

        WHILE a solution is not found
          SET column equal to a random column number between 0 and boardSize
          LOOP from 0 to boardSize

            IF (isDiagonalValid and isHorizontalValid)
              ADD column to the stack
              INCREMENT stack.size
            ELSE IF (stack.size == boardSize)
              SET success to true
              PRINT the result
              BREAK from the loop
     }

     /**
     * An override method used to print the chess board and the positions of the queens.
     * @return String
     *  A string representation of a chess board and the pattern that solved the 8 queens problem
     */
     @override
     private String toString() {
        INIT stringBuilder
        LOOP from 0 to boardSize
          POP a queen off the stack
          ADD the position to the stringBuilder
          ADD a separator indicating a new row and column position on the board

        RETURN stringBuilder
     }
 }

/**********************************************************************************************************************
 * A LinkedStack is a stack of generic types. The stack can have a special "current element", which is the top element
 * in the stack.
 *
 * @note
 *   1. A stack has no size limitations (other than Integer.MAX_VALUE nodes) so will never need to guarantee capacity.
 *
 * @author mlewis
 * @version Oct 8, 2019
 *********************************************************************************************************************/
 public class LinkedStack<E> implements Stack<E> {
    // Invariant of the LinkedStack<E> class.
    //  1. The instance variable top is the head reference in the stack.
    //  2. For the final node in the stack, the next reference is null. Otherwise, the next reference is a reference
    //     to the next node.
    //  3. The stack is a Last-In-First-Out data structure. To access an item other than the first item, you must first
    //     remove every node that sits on top of the target item in the stack.
    //  4. The instance variable size is the number of objects in the stack.
    private int size;
    private Node<E> top;

    /**
    * Initializes an empty stack. Note that the initial top node is null indicating that the stack is empty.
    * @postcondition
    *  This new stack is empty with a null reference in the top node.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for the new stack.
    */
    private LinkedStack() {
        SET size equal to zero
        SET top equal to null
    }

    /**
    * Initializes an empty stack. Note that the initial top node is null indicating that the stack is empty.
    * @postcondition
    *  This new stack is empty with a null reference in the top node.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for the new stack.
    */
    public getInstance() {
        INIT LinkedStack();
    }

    /**
    * Modification method to remove all objects from the stack.
    * @return boolean
    *  Return true if the stack was emptied. Otherwise return false.
    * @postcondition
    *  The stack is now empty and every object (if there any) in the stack is available for garbage collection.
    /*
    public boolean clear() {
        SET top = new Node<E>;
        SET size = 0;
    }

    /**
    * Accessor method to determine if the stack is empty.
    * @return boolean
    *  Returns true if the stack is empty. Otherwise returns false.
    */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
    * Accessor method to look at the object on the top of the stack.
    * @return E
    *  The top object on the stack.
    * @postcondition
    *  The stack is not modified in any way. The top element remains the top of the stack.
    */
    public E peek() {
        IF (size == 0) {
            return null;
        }
        END IF

        GET top.data();
    }

    /**
    * Modification method that retrieves the top object from the stack. The next object (if there is one) is now the
    * new top.
    * @return E
    *  The top object from the stack
    * @postcondition
    *  The top object was removed from the stack and the next object (if there was one) is the new top. Otherwise, the
    *  new top is a null reference. The size of the stack has decreased by one.
    */
    public E pop() {
        INIT E answer;

        IF (size == 0) {
            return null;
        }
        END IF

        SET answer = top.data();
        SET top = top.getNext();
        DECREMENT size--;
        RETURN answer;
    }

    /**
    * Modification method that adds a new object to the top of the stack.
    * @param item
    *  The item being pushed onto the stack.
    * @return E
    *  The item being pushed onto the stack
    * @postcondition
    *  The item is the new top and the size of the stack has increased by one.
    */
    public E push(E item) {
        SET top = new Node(item, top);
        INCREMENT size++;
        RETURN item;
    }

    /**
    * Accessor method that returns the 1-based position of an object on the stack (if the object is on the stack). If
    * the object is not on the stack, the method returns -1.
    * @param obj
    *  The object to search for on the stack.
    * @return int
    *  The 1-based position of the object if it is on the stack. If it is not on the stack, return -1.
    * @postcondition
    *  The stack remains unchanged.
    */
    public int search(Object obj) {
        INIT count;
        INIT Node<E> current;

        SET current = top;
        SET count = 1 // 1-based index
        FOR (every node in the stack) {
             IF (current equals obj) {
                RETURN count;
             }
             END IF
             INCREMENT count++;
        }
        RETURN -1;
    }

    /**
    * Compare this Node to another object for equality
    * @param item
    *  An object with which this Node is being compared.
    * @return boolean
    *  A return value of true indicates that obj refers to a Node object with the same value as this Node. Otherwise,
    *  the return value is false.
    */
    public boolean equals(Object obj) {
        IF (object is an instance of Node<E>) {
            SET obj equal to a Node<E> variable via a shortening typecast
            RETURN (candidate.data == top.data);
        }
        ELSE {
            RETURN false;
        }
        END IF
    }
 }

 // FILE: Node.java from the package edu.bostonuniversity.nodes
 // This is a programming project from chapter 4 of "Data Structures and Other Objects Using Java" by Michael Main.

 package edu.bostonuniversity.nodes;
 import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;


 /**********************************************************************************************************************
  * A generic Node that provides a node for a linked list with a generic type parameter in each node.
  *
  * @note
  *   (1) Lists can be of any length, limited only by the amount of free memory on the heap. But beyond
  *   Integer.MAX_VALUE, the answer from listLength is incorrect because of arithmetic overflow.
  *
  * @author mlewis
  * @version Oct 6, 2019
  *
  *********************************************************************************************************************/

 public class NodeList<E> implements Node<E> {
     // Invariant of the Node class:
     //   1. The node's generic data type is in the instance variable data.
     //   2. For the final node of a list, the link part is null. Otherwise, the link part is a reference to the next
     //      node of the list.
     private E data;
     private NodeList<E> next;

     /**
      * Initializes an empty node. Note that the initial next is a null reference, which indicates that the new node has
      * nothing after it.
      * @postcondition
      *   This new node is an empty node with a null reference as its link.
      * @exception OutOfMemoryError
      *   Indicates insufficient memory for the new Node
      */
     private NodeList() {
         this.data = null;
         this.next = null;
     }

     /**
      * Initializes a node with the specified initial data and a link to the next node. Note that the initial next may
      * be a null reference, which indicates that the new node has nothing after it.
      * @param data
      *   The initial data of this new node.
      * @param next
      *   A reference to the node after this new node (this reference may be null to indicate that there is no node
      *   after this new node).
      * @postcondition
      *   This new node contains the specified data and a link to the next node.
      * @exception OutOfMemoryError
      *   Indicates insufficient memory for the new Node.
      */
     private NodeList(E data, NodeList<E> next) {
         this.data = data;
         this.next = next;
     }

     /**
      * Activates the no arg constructor for Node. Note that the initial next is a null reference, which indicates
      * that the new node has nothing after it.
      * @postcondition
      *   This new node is an empty node with a null reference as its link
      * @return Node
      *   A reference to a new Node object. Initial link is null.
      * @exception OutOfMemoryError
      *   Indicates insufficient memory for the new Node.
      */
     public static <E> NodeList<E> getInstance() { RETURN NodeList }

     /**
      * Activates the overloaded constructor for Node. Note that the initial next may be a null reference, which
      * indicates that the new node has nothing after it.
      * @param data
      *   The initial data of this new node.
      * @param next
      *   A reference to the node after this new node (this reference may be null to indicate that there is no node
      *   after this new node).
      * @return Node
      *   A reference to a new Node object with the specified initial data and initial link (next)
      * @exception OutOfMemoryError
      *   Indicates insufficient memory for the new Node.
      */
     public static <E> NodeList<E> getInstance(E data, NodeList<E> next) { RETURN NodeList }

     /**
      * Modification method to add a new node after this node.
      * @param element
      *   The data to be placed in the new node.
      * @postcondition
      *   A new node has been created and placed after this node. The data for the new node is element. Any other nodes
      *   that used to be after this node are now after the new node.
      * @exception OutOfMemoryError
      *   Indicates that there is insufficient memory for a new Node.
      */
     public void addNodeAfter(E element) {
        SET next to a new NodeList
     }

     /**
      * Accessor method to get the data from this node.
      * @return data
      *   The data from this node.
      */
     public E getData() { RETURN data; }

     /**
      * Accessor method to get a reference to the next node after this node.
      * @return next
      *   A reference to the node after this node (or the null reference if there is nothing after this node).
      */
     public NodeList<E> getNext() { RETURN next; }

     /**
      * Copy a linked list
      * @param source
      *   The head reference for a linked list that will be copied (which may be an empty list where source is null).
      * @return Node
      *   The method has made a copy of the linked list starting at source. The return value is the head reference for
      *   the copy.
      * @exception OutOfMemoryError
      *   Indicates insufficient memory for the new Node.
      */
     public static <E> Node<E> listCopy(NodeList<E> source) {
         INIT a head and tail reference

         WHILE next is not null
             SET source to the next node
             INIT a new node after the current tail
             INCREMENT current tail to the new node
         }

         RETURN head reference;
     }

     /**
      * Copy a list, returning both a head and a tail reference for the copy
      * @param source
      *   The head reference for a linked list that will be copied (which may be an empty list where source is null).
      * @return Node[]
      *   The method has made a copy of the linked list starting at source. The return value is an array where [0]
      *   element is a head reference for the copy and the [1] element is a tail reference for the copy.
      * @exception OutOfMemoryError
      *   Indicates insufficient memory for the new Node.
      */
     public static <E> Object[] listCopyWithTail(NodeList<E> source) {
        INIT a head and tail reference
        INIT an Object array

        SET head reference to a new node with the given source
        SET the tail reference to the head reference

        WHILE next is not null
            SET source to it's next node
            ADD next node after the current tail reference
            SET tail reference to the new node
         }

        SET index 0 to the head reference
        SET index 1 to the tail reference
        RETURN the object array
     }

     /**
      * Compute the number of nodes in a linked list
      * @param head
      *   The head reference for a linked list (which may be an empty list with a null head)
      * @return int
      *   The number of nodes in the list with the given head
      * @note
      *   A wrong answer occurs for lists longer than Integer.MAX_VALUE due to arithmetic overflow.
      */
     public static <E> int listLength(NodeList<E> head) {
        INIT a counter variable
        INIT a NodeList reference

        ITERATE over the nodes and increment the counter
        RETURN counter
     }

     /**
      * Copy part of a list, providing a head and tail reference for the new copy.
      * @param start
      *   A reference to the start node of a linked list
      * @param end
      *   A reference to the end node of a linked list
      * @precondition
      *   Start and end are non-null references to nodes on the same linked list, with the start node at or before the
      *   end node.
      * @return Node[]
      *   The method has made a copy of part of a linked list, from the specified start node to the specified end node.
      *   The return value is an array where the [0] component is a head reference for the copy and the [1] component is
      *   a tail reference for the copy.
      * @exception OutOfMemoryError
      *   Indicates insufficient memory for a new Node.
      * @exception IllegalArgumentException
      *   Indicates that start and end do not satisfy the precondition.
      */
     public static <E> Object[] listPart(NodeList<E> start, Node<E> end) {
        INIT a head reference
        INIT a tail reference
        INIT an array

        SET head reference to a new node with the given source
        SET the tail reference to the head reference

        WHILE start is not equal to end
            SET start to its next node as long as it's not null
            ADD next node after the current tail reference
            SET tail reference to the new node
         }

        SET index 0 to the head reference
        SET index 1 to the tail reference
        RETURN the object array
     }

     /**
      * Find a node at a specified position in a linked list.
      * @param head
      *   The head reference for a linked list (which may be an empty list with a null head)
      * @param position
      *   A node number
      * @return Node
      *   The return value is a reference to the node at the specified position in the list. (The head node is position
      *   1, the next node is position 2, and so on). If there is no such position (because the list is too short), then
      *   null reference is returned.
      * @exception IllegalArgumentException
      *   Indicates a position is less than or equal to 0
      */
     public static <E> Node<E> listPosition(NodeList<E> head, int position) {
        INIT a new reference variable at set it equal to head

        ITERATE over the nodes until the position is found
        RETURN the node found at the given position
     }

     /**
      * Search for a particular piece of data in a linked list.
      * @param head
      *   The head reference for a linked list (which may be an empty list with a null head).
      * @param target
      *   A piece of data to search for.
      * @return Node
      *   The return is a reference to the first node that contains the specified target. If there is no such node, the
      *   null reference is returned.
      */
     public static <E> Node<E> listSearch(NodeList<E> head, E target) {
        INIT a nodelist reference

        ITERATE over the nodes until the target is found
        RETURN the target
     }

     /**
      * Modification method to remove the node after this node.
      * @precondition
      *   This node must not be the tail node of the list.
      * @postcondition
      *   The node after this node has been removed from the linked list. If there were further nodes after that one,
      *   they are still present on the list and the node previous to this node is now linked to the node after this
      *   node.
      * @exception NullPointerException
      *   Indicates that this was the tail node of the list, so there is nothing after it to remove.
      */
     public void removeNodeAfter() { this.next = this.next.next; }

     /**
      * Modification method to set the data in this node.
      * @param data
      *   The new data to place in this node.
      * @postcondition
      *   The data of this node has been set to data
      */
     public void setData(E data) { RETURN data }


     /**
      * Modification method to set a reference to the next node after this node.
      * @param next
      *   A reference to the node that should appear after this node in the linked list (or the null reference if there
      *   should be no node after this node).
      * @postcondition
      *   The link to the node after this node has been set to next. Any other node (that used to be in this link) is no
      *   longer connected to this node.
      */
     public void setNext(Node<E> next) {
        SET the next reference variable to the given node
     }
 }
