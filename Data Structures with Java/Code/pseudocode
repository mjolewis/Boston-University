/**********************************************************************************************************************
 * Pseudocode for homework 2 of Data Structures with Java with Professor Berry
 *
 * @note
 *   1. Pseudocode for the 8 queens problem
 *
 * @author mlewis
 * @version Oct 8, 2019
 *********************************************************************************************************************/

 /**
 * An interface for a stack based data structure. A stack is a Last-In-First-Out (LIFO) data structure. To access an
 * item other than the top item, you must first remove every item that comes before it in the stack.
 public interface Stack<E> {
    boolean isEmpty();
    boolean clear();
    E peek();
    E pop();
    E push(E item);
    int search(Object obj);
 }

/**********************************************************************************************************************
 * A LinkedStack is a stack of generic types. The stack can have a special "current element", which is the top element
 * in the stack.
 *
 * @note
 *   1. A stack has no size limitations (other than Integer.MAX_VALUE nodes) so will never need to guarantee capacity.
 *
 * @author mlewis
 * @version Oct 8, 2019
 *********************************************************************************************************************/
 public class LinkedStack<E> implements Stack<E> {
    // Invariant of the LinkedStack<E> class.
    //  1. The instance variable top is the head reference in the stack.
    //  2. For the final node in the stack, the next reference is null. Otherwise, the next reference is a reference
    //     to the next node.
    //  3. The stack is a Last-In-First-Out data structure. To access an item other than the first item, you must first
    //     remove every node that sits on top of the target item in the stack.
    //  4. The instance variable size is the number of objects in the stack.
    private int size;
    private Node<E> top;

    /**
    * Initializes an empty stack. Note that the initial top node is null indicating that the stack is empty.
    * @postcondition
    *  This new stack is empty with a null reference in the top node.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for the new stack.
    */
    private LinkedStack() {
        SET size equal to zero
        SET top equal to null
    }

    /**
    * Initializes an empty stack. Note that the initial top node is null indicating that the stack is empty.
    * @postcondition
    *  This new stack is empty with a null reference in the top node.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for the new stack.
    */
    public getInstance() {
        INIT LinkedStack();
    }

    /**
    * Modification method to remove all objects from the stack.
    * @return boolean
    *  Return true if the stack was emptied. Otherwise return false.
    * @postcondition
    *  The stack is now empty and every object (if there any) in the stack is available for garbage collection.
    /*
    public boolean clear() {
        SET top = new Node<E>;
        SET size = 0;
    }

    /**
    * Accessor method to determine if the stack is empty.
    * @return boolean
    *  Returns true if the stack is empty. Otherwise returns false.
    */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
    * Accessor method to look at the object on the top of the stack.
    * @return E
    *  The top object on the stack.
    * @postcondition
    *  The stack is not modified in any way. The top element remains the top of the stack.
    */
    public E peek() {
        IF (size == 0) {
            return null;
        }
        END IF

        GET top.data();
    }

    /**
    * Modification method that retrieves the top object from the stack. The next object (if there is one) is now the
    * new top.
    * @return E
    *  The top object from the stack
    * @postcondition
    *  The top object was removed from the stack and the next object (if there was one) is the new top. Otherwise, the
    *  new top is a null reference. The size of the stack has decreased by one.
    */
    public E pop() {
        INIT E answer;

        IF (size == 0) {
            return null;
        }
        END IF

        SET answer = top.data();
        SET top = top.getNext();
        DECREMENT size--;
        RETURN answer;
    }

    /**
    * Modification method that adds a new object to the top of the stack.
    * @param item
    *  The item being pushed onto the stack.
    * @return E
    *  The item being pushed onto the stack
    * @postcondition
    *  The item is the new top and the size of the stack has increased by one.
    */
    public E push(E item) {
        SET top = new Node(item, top);
        INCREMENT size++;
        RETURN item;
    }

    /**
    * Accessor method that returns the 1-based position of an object on the stack (if the object is on the stack). If
    * the object is not on the stack, the method returns -1.
    * @param obj
    *  The object to search for on the stack.
    * @return int
    *  The 1-based position of the object if it is on the stack. If it is not on the stack, return -1.
    * @postcondition
    *  The stack remains unchanged.
    */
    public int search(Object obj) {
        INIT count;
        INIT Node<E> current;

        SET current = top;
        SET count = 1 // 1-based index
        FOR (every node in the stack) {
             IF (current equals obj) {
                RETURN count;
             }
             END IF
             INCREMENT count++;
        }
        RETURN -1;
    }

    /**
    * Compare this Node to another object for equality
    * @param item
    *  An object with which this Node is being compared.
    * @return boolean
    *  A return value of true indicates that obj refers to a Node object with the same value as this Node. Otherwise,
    *  the return value is false.
    */
    public boolean equals(Object obj) {
        IF (object is an instance of Node<E>) {
            SET obj equal to a Node<E> variable via a shortening typecast
            RETURN (candidate.data == top.data);
        }
        ELSE {
            RETURN false;
        }
        END IF
    }
 }

/**********************************************************************************************************************
 * A Game is a sequence of choices attempting to solve the 8 Queens problem on a chess board. Each choice consists of a
 * row and column number and is then pushed onto a LinkedStack.
 *
 * The 8 Queens problem postulates that you can place 8 Queens on a chess board, so that no Queen could capture any
 * other.
 *
 * @note
 *  1. Beyond Integer.MAX_VALUE elements, the size method in LinkedStack does not work.

 * @author mlewis
 * @version Oct 16, 2019
 *********************************************************************************************************************/

 public class Game {
     // Invariant of the Game class.
     //  1. The instance variable stack is a LinkedStack.
     //  2. The instance variable success indicates whether or not a solution to the 8 queens problem has been found.
     //  3. The instance variable boardSize indicates how many rows and columns are on the chess board.
     //  4. Stack will have access to a top node and size variables within the LinkedStack.java class.
     private boolean success;
     private int boardSize;
     private LinkedStack<Integer> stack;

     /**
     * Helper method to determine if there is a diagonal conflict. A diagonal conflict indicates that placing a
     * queen at the given row and column combination would result in an invalid board setup.
     * @param row
     *  Indicates the row on the chess board being tested.
     * @param column
     *  Indicates the column on the chess board being tested.
     * @return boolean
     *  A return value of true indicates that placing a queen on this diagonal path does not violate a valid board set
     *  up. A return value of false indicates that a queen cannot be placed in the given location.
     */
     private boolean isDiagonalValid(int row, int column) {
        LOOP from 0 to boardSize
          CALCULATE slope of current row and column relative to previous row and column
          IF slope equals one
            THEN a conflict exists
            RETURN false
          ELSE
            Current row and column is a valid option
            RETURN true
     }

      /**
      * Helper method to determine if there is a horizontal conflict. A horizontal conflict indicates that placing a
      * queen at the given row and column combination would result in an invalid board setup.
      * @param row
      *  Indicates the row on the chess board being tested.
      * @return boolean
      *  A return value of true indicates that placing a queen on this horizontal path does not violate a valid board
      *  set up. A return value of false indicates that a queen cannot be placed in the given location.
      */
     private boolean isHorizontalValid(int row) {
        LOOP from 0 to boardSize
          IF current row equals the row of the previous queen
            THEN a conflict exists
            RETURN false
          ELSE
            Current row is a valid option
            RETURN true
     }

     /**
     * Helper method used that plays the 8 queens game until a solution is found.
     * @param stack
     *  The stack is a LinkedStack used to store the positions of the queens on the board.
     * @precondition
     *  A chess board has been constructed.
     * @return LinkedStack
     *  A LinkedStack that contains solution to the 8 queens problem
     * @postcondition
     *  A solution to the 8 queens problem has been found
     */
     public LinkedStack<Integer> play() {
        INIT column

        WHILE a solution is not found
          SET column equal to a random column number between 0 and boardSize
          LOOP from 0 to boardSize

            IF (isDiagonalValid and isHorizontalValid)
              ADD column to the stack
              INCREMENT stack.size
            ELSE IF (stack.size == boardSize)
              SET success to true
              PRINT the result
              BREAK from the loop
     }

     /**
     * An override method used to print the chess board and the positions of the queens.
     * @return String
     *  A string representation of a chess board and the pattern that solved the 8 queens problem
     */
     @override
     private String toString() {
        INIT stringBuilder
        LOOP from 0 to boardSize
          POP a queen off the stack
          ADD the position to the stringBuilder
          ADD a separator indicating a new row and column position on the board

        RETURN stringBuilder
     }
 }
