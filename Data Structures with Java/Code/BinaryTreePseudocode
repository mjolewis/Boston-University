/**********************************************************************************************************************
 * Pseudocode for the Binary Tree project. Programming project 3 for Data Structures with Java with Professor Berry.
 *
 * @author mlewis
 * @version November 27, 2019
 *********************************************************************************************************************/

/**********************************************************************************************************************
 * A BTNode<E> provides a node for a binary tree with a reference to an E object as the data in each node.
 *
 * @note
 *  Beyond Integer.MAX_VALUE elements, treeSize is wrong.
 *
 * @author mlewis
 * @version Nov 3, 2019
 *********************************************************************************************************************/

 public class BTNode<E> {
    // Invariant of the BTNode<E> class
    //  1. The instance variable count counts the number of times data has occurred in the tree. Thus, our programming
    //     will prevent duplicate entries in the tree and instead count the number of duplicates.
    //  2. The instance variable data stores the data of each node.
    //  3. The instance variable left is a reference to the left child of the activating node. If there is no left
    //     child, left is a null reference.
    //  4. The instance variable right is a reference to the right child of the activating node. If there is no right
    //     child, right is a null reference.
    private int count;
    private E data;
    private BTNode<E> left;
    private BTNode<E> right;

    /**
     * public BTNode()
     * Initialize an empty binary tree.
     * @postcondition
     *  An empty binary tree has been initialized.
     * @exception OutOfMemoryError
     *  Indicates insufficient memory for this binary tree.
     */
    public BTNode() {
        INIT data = null;
        INIT left = null;
        INIT right = null;
    }

    /**
     * public BTNode(E data, BTNode<E> left, BTNode<E> right)
     * Initialize a new binary tree with the specified data and child references (left and right). Note that the child
     * reference variables can be null, which indicates that there is no left and/or right child(ren).
     * @param data
     *  The initial data for this new node.
     * @param left
     *  The initial reference to this nodes left child. Note that this can be a null reference, which indicates that
     *  there is no left child.
     * @param right
     *  The initial reference to this nodes right child. Note that this can be a null reference, which indicates that
     *  there is no right child.
     */
    public BTNode(E data, BTNode<E> left, BTNode<E> right) {
        INIT data = data;
        INIT left = left;
        INIT right = right;
    }

    /**
     * public E getData()
     * Accessor method to retrieve the activating nodes data.
     * @return E
     *  The activating nodes data.
     */
    public E getData() {
        RETURN data;
    }

    /**
     * public int getCount()
     * Accessor method that returns how many times this node has been accessed.
     * @return int
     *  The number of times this node has been accessed.
     */
    public int getCount() {
        RETURN count;
    }

    /**
     * public BTNode<E> getLeft()
     * Accessor method that returns a reference to the activating nodes left child.
     * @return BTNode<E>
     *  A reference to this nodes left child. Note that this may be a null reference, which indicates that there is no
     *  left child.
     */
    public BTNode<E> getLeft() {
        RETURN left
    }

    /**
     * public E getLeftmostData()
     * Accessor method that return the data from the leftmost node of the activating node.
     * @return E
     *  The data from the deepest node that can be reached by following the activating nodes left path.
     */
    public E getLeftmostData() {
        IF left child is null (base case of recursive call)
            RETURN activating node
        ELSE
            RETURN recursive call to getLeftmostData to traverse down the tree
    }

    /**
     * public BTNode<E> getRight()
     * Accessor method that returns a reference to the activating nodes right child.
     * @return BTNode<E>
     *  A reference to this nodes right child. Note that this may be a null reference, which indicates that there is no
     *  right child.
     */
    public BTNode<E> getRight() {
        RETURN right
    }

    /**
     * public E getRightmostData()
     * Accessor method that returns the data from the rightmost node of the activating node.
     * @return E
     *  The data from the deepest node that can be reached by following the activating nodes right path.
     */
    public E getRightmostData() {
        IF right child is null (base case of recursive call)
            RETURN activating node
        ELSE
            RETURN recursive call to getRightmostData to traverse down the tree
    }

    /**
     * public void incrementCount()
     * Mutator method that increments the instance variable count by one.
     * @postcondition
     *  The instance variable count has been incremented by one.
     */
    public void incrementCount() {
        INCREMENT count
     }

    /**
     * public boolean isLeaf()
     * Accessor method to determine if the activating node is a leaf.
     * @return boolean
     *  True if the activating node is a leaf. Otherwise false.
     */
    public boolean isLeaf() {
        IF left child = null && right child == null
            RETURN true
        ELSE return false
    }

    /**
     * public void inorderPrint()
     * An in-order traversal to print the data from this node and all of its descendants in the binary tree.
     * @postcondition
     *  The data of this node and all of its descendants have been written by System.out.println().
     */
    public void inorderPrint() {
        TRAVERSE the tree down the left child pathway
        IF left child becomes null
            TRAVERSE back up the tree and print the data from each node
        TRAVERSE the tree down the right child pathway
        IF right child becomes null
            TRAVERSE back up the tree and print the data from each node
    }

    /**
     * public void preorderPrint()
     * An pre-order traversal to print the data from this node and all of its descendants in the binary tree.
     * @postcondition
     *  The data of this node and all of its descendants have been written by System.out.println().
     */
    public void preorderPrint() {
        PRINT data from the activating node
        TRAVERSE the tree down the left child pathway
        IF left child becomes null
            TRAVERSE the tree down the right child pathway
            IF right child pathway is null
                END traversal
    }

    /**
     * public void postorderPrint()
     * An post-order traversal to print the data from this node and all of its descendants in the binary tree.
     * @postcondition
     *  The data of this node and all of its descendants have been written by System.out.println().
     */
    public void postorderPrint() {
        TRAVERSE the tree down the left child pathway until the left child become null
        TRAVERSE the tree down the right child pathway until the right child becomes null
        PRINT the data from each node as you traverse back up the tree
    }

    /**
     * public BTNode<E> removeLeftmost()
     * Mutator method that removes the left most node starting from the activating nodes root.
     * @return BTNode<E>
     *  A reference to the root of the newly modified binary tree. Note that the return value can be null if the
     *  original binary tree had only one node (which has been removed).
     * @postcondition
     *  The binary tree starting at the activating node has had its leftmost node removed.
     */
    public BTNode<E> removeLeftmost() {
        INIT base case
        TRAVERSE the tree down the left child pathway
        RETURN a reference to the activating object
    }

    /**
     * public BTNode<E> removeRightmost()
     * Mutator method that removes the right most node starting from the activating nodes root.
     * @return BTNode<E>
     *  A reference to the root of the newly modified binary tree. Note that the return value can be null if the
     *  original binary tree had only one node (which has been removed).
     * @postcondition
     *  The binary tree starting at the activating node has had its rightmost node removed.
     */
    public BTNode<E> removeRightmost() {
        INIT base case
        TRAVERSE the tree down the right child pathway
        RETURN a reference to the activating object
    }

    /**
     * public void setData()
     * Mutator method that updates the data in the activating node to the specified data.
     * @param data
     *  The new data for the activating node.
     * @postcondition
     *  The data for the activating node has been set to the specified data.
     */
    public void setData(E data) {
        SET data = data;
    }

    /**
     * public void setLeft()
     * Mutator method that updates the reference of the left node to the specified node.
     * @param left
     *  The new reference node for this activating objects left child.
     * @postcondition
     *  The reference variable left for the activating node has been set to the specified reference variable.
     */
    public void setLeft(BTNode<E> left) {
        SET left = left;
    }

    /**
     * public void setRight()
     * Mutator method that updates the reference of the right node to the specified node.
     * @param right
     *  The new reference node for this activating objects right child.
     * @postcondition
     *  The reference variable right for the activating node has been set to the specified reference variable.
     */
    public void setRight(BTNode<E> right) {
        SET right = right;
    }

    /**
     * public static <E> BTNode<E> treeCopy(BTNode<E> source)
     * Copy a binary tree.
     * @param source
     *  A reference to the root node of the binary tree to be copied. Note that the root may be a null reference.
     * @return BTNode<E>
     *  A copy of the binary tree starting at the source. The return value is a reference to the root node.
     * @postcondition
     *  A binary tree has been copied.
     * @exception OutOfMemoryError
     *  Indicates insufficient memory for this new binary tree.
     */
    public static <E> BTNode<E> treeCopy(BTNode<E> source) {
        INIT a variable to hold a copy of the left side of the tree
        INIT a variable to hold a copy of the right side of the tree
        IF the argument is null
            RETURN null to handle exception to avoid null pointer exception
        TRAVERSE the left side of the tree through a recursive call
        TRAVERSE the right side of the tree through a recursive call
        RETURN the new tree
    }

    /**
    * public static <E> int treeDepth(BTNode<E> root)
    * Computer the depth of this binary tree.
    * @param root
    *  A reference to the root of a binary tree (which may be an empty tree with a null root).
    * @return int
    *  The depth of this binary tree.
    * @note
    *  A wrong answer occurs for trees larger than Integer.MAX_VALUE.
    */
    public static <E> int treeDepth(BTNode<E> root) {
        TRAVERSE the left side of the tree and increment count by 1
        TRAVESE the right side of the tree and increment count by 1
        RETURN the maximum of left side count and right side count
    }

    /**
     * public static <E> int treeSize(BTNode<E> root)
     * Compute the number of nodes in this binary tree.
     * @param root
     *  A reference to the root of a binary tree (which may be an empty tree with a null root).
     * @return int
     *  The number of nodes in this binary tree.
     * @note
     *  A wrong answer occurs for trees larger than Integer.MAX_VALUE.
     */
    public static <E> int treeSize(BTNode<E> root) {
        IF root is null
            RETURN 0 as the base case
        ELSE
            RETURN 1 + recursive call for both the left and right sides of the tree
    }
 }


/**********************************************************************************************************************
 * A BinarySearchTree class reads in a text file and maps each word to a node in a Binary Tree. If the word is already
 * in this Binary Tree, we increment a counter instead of adding a duplicate. The BinarySearchTree is capable of
 * performing queries on the text.
 *
 * @author mlewis
 * @version November 27, 2019
 *********************************************************************************************************************/

public class BinarySearchTree {
    // Invariant of the BinarySearchTree.java class
    //  1. The instance variable root in the root node of the Binary Search Tree.
    //  2. The instance variable count is a reference to the total number of elements added to this Binary Search Tree.
    //  3. The instance variable maxOccurrence is the number of times the most frequent element occurred in this
    //     Binary Search Tree.
    //  4. The instance variable mostFrequent is a reference to the data that most frequently occurred in this Binary
    //     Search Tree.
    //  5. The instance variable MAX_DEPTH is the maximum depth allowed during any print traversal activation.
    //  6. The instance variable depth is a static variable used to terminate the recursive print traversal
    //     activations.
    private BTNode<T> root;
    private int count;
    private int maxOccurrence;
    private T mostFrequent;
    private static final int MAX_DEPTH = 20;
    private static int depth = 0;

    /**
    * public BinarySearchTree()
    * Initializes an empty BinarySearchTree.
    * @postcondition
    *  An empty BinarySearchTree has been initialized.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for this BinarySearchTree.
    */
    public BinarySearchTree() {
        INIT root = null;
        INIT new parser object
    }

    /**
    * private void add(String word)
    * A helper method that adds the given word to a node in the binary tree. If the word is already in the binary tree
    * then we do not add the word and instead update the instance variable counter associated with the given word.
    * @param String word
    *  The word to add to the binary tree. If the word is already in the tree, we do not add it. Instead, we increment
    *  the words counter.
    * @postcondition
    *  The word has been added to the binary tree if it did not exist. Otherwise, the words counter has been
    *  incremented.
    */
    private void add(String word) {
        TRAVERSE the tree
        IF word already exists in the tree
            INCREMENT counter
        ELSE
            ADD the word to the tree in alphabetic order
            INCREMENT counter
    }

    /**
    * public int getCount()
    * Accessor method that returns a reference to the total number of elements processed by this Binary Search Tree.
    * @return int
    *  The total number of elements processed by this Binary Search Tree.
    */
    public int getCount() {
        RETURN count;
    }

    /**
    * public T getMostFrequent()
    * Accessor method that returns a reference to the most frequently occurring element in this Binary Search Tree.
    * @return T
    *  A reference to the most frequently occurring element in this Binary Search Tree.
    */
    public T getMostFrequent() {
        RETURN mostFrequent;
    }

    /**
    * public BTNode<T> getRoot()
    * Accessor method that returns the root node of this binary tree.
    * @return BTNode<T>
    *  The root node of this binary tree.
    */
    public BTNode<T> getRoot() {
        RETURN root node
    }

    /**
     * public void inorderTraversal(BTNode<T> cursor)
     * An inorder traversal to print the data from the first 20 nodes in this Binary Search Tree.
     * @postcondition
     *  The data of the first 20 nodes have been written by System.out.println().
     */
    public void postorderTraversal(BTNode<T> cursor) {
        TRAVERSE the tree down the left child pathway
        IF left child becomes null
            PRINT data from the activating node
        TRAVERSE the tree down the right child pathway
            IF right child pathway is null
                END traversal
    }

    /**
    * public T mostFrequent()
    * Accessor method that returns a reference to the element that occurs most frequently.
    * @return T
    *  The element that occurs most frequently.
    */
    public T mostFrequent() {
        INIT count
        INIT answer
        TRAVERSE the tree
        IF the count of the current node > than count
            UPDATE count
            UPDATE answer
        ELSE
            TRAVERSE the tree until there are no more nodes to search
    }

    /**
     * public void postorderTraversal(BTNode<T> cursor)
     * An post-order traversal to print the data from the first 20 nodes in this Binary Search Tree.
     * @postcondition
     *  The data of the first 20 nodes have been written by System.out.println().
     */
    public void postorderTraversal(BTNode<T> cursor) {
        TRAVERSE the tree down the left child pathway
        IF left child becomes null
            TRAVERSE the tree down the right child pathway
            IF right child pathway is null
                END traversal
        PRINT data from the activating node
    }

    /**
     * public void preorderTraversal()
     * An pre-order traversal to print the data from this node and all of its descendants in the binary tree.
     * @postcondition
     *  The data of this node and all of its descendants have been written by System.out.println().
     */
    public void preorderTraversal() {
        PRINT data from the activating node
        TRAVERSE the tree down the left child pathway
        IF left child becomes null
            TRAVERSE the tree down the right child pathway
            IF right child pathway is null
                END traversal
    }

    /**
     * public int size()
     * Accessor method that determines how many nodes are in this tree.
     * @return int
     *  The number of nodes in this tree.
     */
    public int size() {
        INIT count;

        TRAVERSE the left side of the tree
            IF left child is not null
                INCREMENT count
        TRAVERSE the right side of the tree
            IF right child is not null
                INCREMENT count
    }

    /**
    * public int search(String element)
    * Accessor method that returns the number of times the specified element was processed by this Binary Search Tree.
    * @param element
    *  The element to search for in this Binary Search Tree.
    * @return int
    *  The number of times the specified element was processed by this Binary Search Tree.
    */
    public int search(String element) {
        TRAVERSE the tree
        IF the data of any given node matches the specified element
            RETURN the count attached to that node
        ELSE
            CONTINUE searching until you have search the entire tree
    }

    /**
    * public void setDepth(int depth)
    * Mutator method that sets the instance variable depth to the specified depth
    * @param
    *  The target depth.
    * @postcondition
    *  The instance variable depth has been initialized to the specified depth.
    */
    public void setDepth(int depth) {
        SET this.depth = depth
    }

    /**
    * public String toString()
    * Print the data in every node within this binary tree.
    * @return String
    *  The data from each node in this binary tree.
    public String toString() {
        ACTIVATE preorder print from BTNode class
    }
}

/**********************************************************************************************************************
 * BinarySearchTreeMain initializes a BinarySearchTree object that is used to read in a body of text, insert the text
 * into a binary tree, and answer a series of questions about the body of text.
 *
 * @author mlewis
 * @version November 28, 2019
 *********************************************************************************************************************/

public class BinarySearchTreeMain {
    // Invariant of the BinarySearchTreeMain class.
    //  1. The instance variable FILE_NAME is an absolute pathname to a text file on your local system.
    //  2. The instance variable binarySearchTree is a BinarySearchTree object used to build a binary tree from the
    //     text from the text stored in FILE_NAME.
    //  3. The instance variable parser is a TextParser object used to read in a text file stored at FILE_NAME.
    //  4. The instance variable fileExists is a boolean object used to confirm whether or not the file stored in
    //     FILE_NAME exists and has been opened for processing.
    private static final String FILE_NAME = "/Users/mlewis/Downloads/Dracula.txt";
    private BinarySearchTree<String> binarySearchTree;
    private TextParser parser;
    private boolean fileExists;

    /**
     * public static void main(String[] args)
     * The main entry point for the BinarySearchTree.java class
     * @param args
     *  The required signature for Java's main method.
     */
    public static void main(String[] args) {
        INIT BinarySearchTreeMain
        INIT the start method to open the file
    }

    /**
     * public void buildTree(TextParser file)
     * Builds a binary search tree from the text stored in the specified file.
     * @postcondition
     *  A binary search tree has been built using the text stored in the specified file.
     */
    public void buildTree(TextParser file) {
        INIT BinarySearchTree
        ACTIVATE the parser method within BinarySearchTree
    }

    /**
     * public void openFIle(String fileName)
     * @param fileName
     *  The absolute pathname for a file on your local system.
     * @postcondition
     *  If the file exists, then it has been opened.
     */
    public void openFile(String fileName) {
        INIT TextParser;
        TRY to open the specified file
        IF file exists
            ACTIVATE the buildtree method
    }

    /**
    * public void query()
    * Query the binary search tree to programmatically answer a series of questions.
    * @postcondition
    *  All questions have programmatically been answered and written to the terminal using System.out.println().
    */
    public void query() {
        DISPLAY questions being asked
        QUERY the binary search tree
        DISPLAY the result to the terminal
    }
}