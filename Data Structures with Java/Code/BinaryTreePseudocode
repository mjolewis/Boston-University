/**********************************************************************************************************************
 * Pseudocode for the Binary Tree project. Programming project 3 for Data Structures with Java with Professor Berry.
 *
 * @author mlewis
 * @version November 27, 2019
 *********************************************************************************************************************/

/**********************************************************************************************************************
 * A BTNode<E> provides a node for a binary tree with a reference to an E object as the data in each node.
 *
 * @note
 *  Beyond Integer.MAX_VALUE elements, treeSize is wrong.
 *
 * @author mlewis
 * @version Nov 3, 2019
 *********************************************************************************************************************/

 public class BTNode<E> {
    // Invariant of the BTNode<E> class
    //  1. The instance variable count counts the number of times data has occurred in the tree. Thus, our programming
    //     will prevent duplicate entries in the tree and instead count the number of duplicates.
    //  2. The instance variable data stores the data of each node.
    //  3. The instance variable left is a reference to the left child of the activating node. If there is no left
    //     child, left is a null reference.
    //  4. The instance variable right is a reference to the right child of the activating node. If there is no right
    //     child, right is a null reference.
    private int count;
    private E data;
    private BTNode<E> left;
    private BTNode<E> right;

    /**
     * public BTNode()
     * Initialize an empty binary tree.
     * @postcondition
     *  An empty binary tree has been initialized.
     * @exception OutOfMemoryError
     *  Indicates insufficient memory for this binary tree.
     */
    public BTNode() {
        INIT data = null;
        INIT left = null;
        INIT right = null;
    }

    /**
     * public BTNode(E data, BTNode<E> left, BTNode<E> right)
     * Initialize a new binary tree with the specified data and child references (left and right). Note that the child
     * reference variables can be null, which indicates that there is no left and/or right child(ren).
     * @param data
     *  The initial data for this new node.
     * @param left
     *  The initial reference to this nodes left child. Note that this can be a null reference, which indicates that
     *  there is no left child.
     * @param right
     *  The initial reference to this nodes right child. Note that this can be a null reference, which indicates that
     *  there is no right child.
     */
    public BTNode(E data, BTNode<E> left, BTNode<E> right) {
        INIT data = data;
        INIT left = left;
        INIT right = right;
    }

    /**
     * public E getData()
     * Accessor method to retrieve the activating nodes data.
     * @return E
     *  The activating nodes data.
     */
    public E getData() {
        RETURN data;
    }

    /**
     * public int getCount()
     * Accessor method that returns how many times this node has been accessed.
     * @return int
     *  The number of times this node has been accessed.
     */
    public int getCount() {
        RETURN count;
    }

    /**
     * public BTNode<E> getLeft()
     * Accessor method that returns a reference to the activating nodes left child.
     * @return BTNode<E>
     *  A reference to this nodes left child. Note that this may be a null reference, which indicates that there is no
     *  left child.
     */
    public BTNode<E> getLeft() {
        RETURN left
    }

    /**
     * public E getLeftmostData()
     * Accessor method that return the data from the leftmost node of the activating node.
     * @return E
     *  The data from the deepest node that can be reached by following the activating nodes left path.
     */
    public E getLeftmostData() {
        IF left child is null (base case of recursive call)
            RETURN activating node
        ELSE
            RETURN recursive call to getLeftmostData to traverse down the tree
    }

    /**
     * public BTNode<E> getRight()
     * Accessor method that returns a reference to the activating nodes right child.
     * @return BTNode<E>
     *  A reference to this nodes right child. Note that this may be a null reference, which indicates that there is no
     *  right child.
     */
    public BTNode<E> getRight() {
        RETURN right
    }

    /**
     * public E getRightmostData()
     * Accessor method that returns the data from the rightmost node of the activating node.
     * @return E
     *  The data from the deepest node that can be reached by following the activating nodes right path.
     */
    public E getRightmostData() {
        IF right child is null (base case of recursive call)
            RETURN activating node
        ELSE
            RETURN recursive call to getRightmostData to traverse down the tree
    }

    /**
     * public void incrementCount()
     * Mutator method that increments the instance variable count by one.
     * @postcondition
     *  The instance variable count has been incremented by one.
     */
    public void incrementCount() {
        INCREMENT count
     }

    /**
     * public boolean isLeaf()
     * Accessor method to determine if the activating node is a leaf.
     * @return boolean
     *  True if the activating node is a leaf. Otherwise false.
     */
    public boolean isLeaf() {
        IF left child = null && right child == null
            RETURN true
        ELSE return false
    }

    /**
     * public void inorderPrint()
     * An in-order traversal to print the data from this node and all of its descendants in the binary tree.
     * @postcondition
     *  The data of this node and all of its descendants have been written by System.out.println().
     */
    public void inorderPrint() {
        TRAVERSE the tree down the left child pathway
        IF left child becomes null
            TRAVERSE back up the tree and print the data from each node
        TRAVERSE the tree down the right child pathway
        IF right child becomes null
            TRAVERSE back up the tree and print the data from each node
    }

    /**
     * public void preorderPrint()
     * An pre-order traversal to print the data from this node and all of its descendants in the binary tree.
     * @postcondition
     *  The data of this node and all of its descendants have been written by System.out.println().
     */
    public void preorderPrint() {
        PRINT data from the activating node
        TRAVERSE the tree down the left child pathway
        IF left child becomes null
            TRAVERSE the tree down the right child pathway
            IF right child pathway is null
                END traversal
    }

    /**
     * public void postorderPrint()
     * An post-order traversal to print the data from this node and all of its descendants in the binary tree.
     * @postcondition
     *  The data of this node and all of its descendants have been written by System.out.println().
     */
    public void postorderPrint() {
        TRAVERSE the tree down the left child pathway until the left child become null
        TRAVERSE the tree down the right child pathway until the right child becomes null
        PRINT the data from each node as you traverse back up the tree
    }

    /**
     * public BTNode<E> removeLeftmost()
     * Mutator method that removes the left most node starting from the activating nodes root.
     * @return BTNode<E>
     *  A reference to the root of the newly modified binary tree. Note that the return value can be null if the
     *  original binary tree had only one node (which has been removed).
     * @postcondition
     *  The binary tree starting at the activating node has had its leftmost node removed.
     */
    public BTNode<E> removeLeftmost() {
        INIT base case
        TRAVERSE the tree down the left child pathway
        RETURN a reference to the activating object
    }

    /**
     * public BTNode<E> removeRightmost()
     * Mutator method that removes the right most node starting from the activating nodes root.
     * @return BTNode<E>
     *  A reference to the root of the newly modified binary tree. Note that the return value can be null if the
     *  original binary tree had only one node (which has been removed).
     * @postcondition
     *  The binary tree starting at the activating node has had its rightmost node removed.
     */
    public BTNode<E> removeRightmost() {
        INIT base case
        TRAVERSE the tree down the right child pathway
        RETURN a reference to the activating object
    }

    /**
     * public void setData()
     * Mutator method that updates the data in the activating node to the specified data.
     * @param data
     *  The new data for the activating node.
     * @postcondition
     *  The data for the activating node has been set to the specified data.
     */
    public void setData(E data) {
        SET data = data;
    }

    /**
     * public void setLeft()
     * Mutator method that updates the reference of the left node to the specified node.
     * @param left
     *  The new reference node for this activating objects left child.
     * @postcondition
     *  The reference variable left for the activating node has been set to the specified reference variable.
     */
    public void setLeft(BTNode<E> left) {
        SET left = left;
    }

    /**
     * public void setRight()
     * Mutator method that updates the reference of the right node to the specified node.
     * @param right
     *  The new reference node for this activating objects right child.
     * @postcondition
     *  The reference variable right for the activating node has been set to the specified reference variable.
     */
    public void setRight(BTNode<E> right) {
        SET right = right;
    }

    /**
     * public static <E> BTNode<E> treeCopy(BTNode<E> source)
     * Copy a binary tree.
     * @param source
     *  A reference to the root node of the binary tree to be copied. Note that the root may be a null reference.
     * @return BTNode<E>
     *  A copy of the binary tree starting at the source. The return value is a reference to the root node.
     * @postcondition
     *  A binary tree has been copied.
     * @exception OutOfMemoryError
     *  Indicates insufficient memory for this new binary tree.
     */
    public static <E> BTNode<E> treeCopy(BTNode<E> source) {
        INIT a variable to hold a copy of the left side of the tree
        INIT a variable to hold a copy of the right side of the tree
        IF the argument is null
            RETURN null to handle exception to avoid null pointer exception
        TRAVERSE the left side of the tree through a recursive call
        TRAVERSE the right side of the tree through a recursive call
        RETURN the new tree
    }

    /**
     * public static <E> int treeSize(BTNode<E> root)
     * Compute the number of nodes in this binary tree.
     * @param root
     *  A reference to the root of a binary tree (which may be an empty tree with a null root).
     * @return int
     *  The number of nodes in this binary tree.
     * @note
     *  A wrong answer occurs for trees larger than Integer.MAX_VALUE.
     */
    public static <E> int treeSize(BTNode<E> root) {
        IF root is null
            RETURN 0 as the base case
        ELSE
            RETURN 1 + recursive call for both the left and right sides of the tree
    }
 }


/**********************************************************************************************************************
 * A TextAnalyzer class reads in a text file and maps each word to a node in a Binary Tree. If the word is already in
 * this Binary Tree, we increment a counter instead of adding a duplicate. The TextAnalyzer is capable of performing
 * queries on the text.
 *
 * @author mlewis
 * @version November 27, 2019
 *********************************************************************************************************************/

public class TextAnalyzer {
    // Invariant of the TextAnalyzer.java class
    //  1. The instance variable scanner is a Scanner object used to read in a text file.
    //  2. The instance variable root in the root node of the Binary Tree.
    private Scanner scanner;
    private BTNode<E> root;

    /**
    * public TextAnalyzer()
    * Initializes an empty TextAnalyzer.
    * @postcondition
    *  An empty TextAnalyzer has been initialized.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for this TextAnalyzer.
    */
    public TextAnalyzer() {
        scanner = new Scanner();
    }

    /**
    * private void add(String word)
    * A helper method that adds the given word to a node in the binary tree. If the word is already in the binary tree
    * then we do not add the word and instead update the instance variable counter associated with the given word.
    * @param String word
    *  The word to add to the binary tree. If the word is already in the tree, we do not add it. Instead, we increment
    *  the words counter.
    * @postcondition
    *  The word has been added to the binary tree if it did not exist. Otherwise, the words counter has been
    *  incremented.
    */
    private void parseText(String word) {
        TRAVERSE the tree
        IF word already exists in the tree
            INCREMENT counter
        ELSE
            ADD the word to the tree
            INCREMENT counter
    }

}