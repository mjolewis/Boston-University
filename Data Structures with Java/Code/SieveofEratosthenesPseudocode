/**********************************************************************************************************************
 * Pseudocode for programming project 2 of Data Structures with Java with Professor Berry
 *
 * @note
 *   1. Pseudocode for the Sieve of Eratosthenes
 *
 * @author mlewis
 * @version Nov 8, 2019
 *********************************************************************************************************************/

/*********************************************************************************************************************
* A user input class builds a GUI with a text input field and a return button. This class implements the
* ActionListener interface.
*
* @author mlewis
* @version Nov 8, 2019
*********************************************************************************************************************/

public class BuildGUI implements ActionListener {
    // Invariant of the UserInput.java class.
    //  1. The instance variable userInput stores the value entered by the user.
    int userInput;

    /**
    * public void constructGUI()
    * Constructs a GUI
    * @postcondition
    *  A GUID has been constructed.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for this GUI
    public void constructGUI() {
        INIT GUI frame
        INIT GUI panel
        INIT GUI button
        INIT GUI text field

        ADD ActionListener to button
        ADD panel to frame
        ADD button to frame

        SET frame size
        SET frame to visible
    }

    /**
    * private void actionPerformed(ActionEvent e)
    * Helper method that captures the users input.
    * @param e
    *  An action event listener object.
    * @postcondition
    *  The user has pressed the submit button and the input has been stored in the instance variable userInput. The
    *  test field has been cleared and focus has been restored to the text field.
    */
    private void actionPerformed(ActionEvent e) {
        SET userInput variable to text submitted by user
        CLEAR text field
        SET focus back to empty text field
    }

    /**
    * public CalculatePrimes getPrimes()
    * Accessor method that returns a reference to a CalculatePrimes object
    * @return CalculatePrimes
    *  A reference to a CalculatePrimes object.
    */
    public CalculatePrimes getPrimes() {
        return primes;
    }
}

/**********************************************************************************************************************
* A calculate primes class uses the Sieve of Eratosthenes to calculate all the prime numbers up to some integer n. The
* technique was developed by a Greek mathematician and poet Eratosthenes who lived in the third century BC and it is
* implemented with an array-based queue.
*
* @note
*  1) Beyond Integer.MAX_VALUE elements, the array-based queue won't work properly.
*
* @author mlewis
* @version Nov 9, 2019
**********************************************************************************************************************/

public class CalculatePrimes {
    // Invariant of the CalculatePrimes class.
    //  1. The instance variable numbers is an array-based queue that has been initialized with consecutive integers 2
    //     through n inclusive if the value of n is greater than START_VALUE (+) MINIMUM_SIZE. Otherwise, the
    //     array-based queue has been initialized with 10 elements starting with the START_VALUE.
    //  2. The instance variable primes is an array-based queue that stores all the prime numbers calculated by the
    //     Sieve of Eratosthenes algorithm.
    //  3. The instance variable START_VALUE is the first element in the numbers array.
    //  4. The instance variable MINIMUM_SIZE guarantees the minimum size of the numbers array.
    private ArrayQueue<Integer> numbers;
    private ArrayQueue<Integer> primes;
    private int maxNumber;
    private static final int START_VALUE = 2;

    /**
    * public CalculatePrimes()
    * Default constructor that initializes the numbers queue with 10 elements.
    * @postcondition
    *  The numbers queue has been initialized with 10 elements.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for this queue.
    */
    public CalculatePrimes() {
        INIT numbers array to minimum number of elements.
        INIT primes array to minimum number of elements.
        ACTIVATE the addAll method to fill the numbers queue from 2 to size inclusive
    }

    /**
    * public CalculatePrimes(int maxNumber)
    * Overloaded constructor that initializes the numbers queue with consecutive integers 2 through n inclusive.
    * @postcondition
    *  The numbers queue has been initialized with consecutive integers 2 through n inclusive.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for this queue.
    */
    public CalculatePrimes(int maxNumber) {
        INIT default constructor
        INIT maxNumber to maxNumber
        ACTIVATE the addAll method to fill the numbers queue from 2 to size inclusive
    }

    /**
    * private void addAll(int n)
    * Helper method that adds numbers 2 through n to the numbers queue. The numbers queue will automatically resize
    * if its capacity has been reached.
    * @param n
    *  The largest number to be added to the numbers queue. The numbers are added from 2 to n inclusive.
    * @precondition
    *  The user has entered a positive integer.
    * @postcondition
    *  The numbers 2 through n have been added to the numbers queue.
    */
    public void addAll(int n) {
        LOOP from 2 to n + 2
            ADD the numbers (first number is two) to the end of the numbers queue
    }


    /**
    * public ArrayQueue<E> findAllPrimes()
    * A method that finds all prime numbers from 2 to n inclusive. The method adds all prime numbers to an array-based
    * queue that automatically resizes if it's capacity has been reached.
    * @precondition
    *  The numbers 2 through n have been added to the numbers queue.
    * @return ArrayQueue<E>
    *  An array-based queue filled with all prime numbers from 2 to n inclusive.
    * @postcodition
    *  All prime numbers from 2 to n inclusive have been added to the primes queue.
    */
    public ArrayQueue<E> findAllPrimes() {
        DO
            Obtain the next prime p by removing the first value from the numbers queue.
            ADD p to the queue of primes
            LOOP over the numbers queue and eliminate numbers divisible b y p
        WHILE
            p < sqrt(n)

        ADD all remaining numbers from the numbers queue to the primes queue

        RETURN the prime queue
    }

    /**
    * public ArrayQueue getNumbers()
    * Accessor method that returns a reference to the numbers ArrayQueue.
    * @return ArrayQueue
    *  A reference to the numbers ArrayQueue
    */
    public ArrayQueue getNumbers() {
        return numbers;
    }

    /**
    * public ArrayQueue getPrimes()
    * Accessor method that returns a reference to the primes ArrayQueue.
    * @return ArrayQueue
    *  A reference to the primes ArrayQueue
    */
    public ArrayQueue getPrimes() {
        return primes;
    }
}

/**********************************************************************************************************************
 * A ArrayQueue is a First-in/First-out data structure of ordered items such that items can be inserted at one end
 * (called the rear) and removed from the other end (called the front). The item at the front of the Queue is called
 * the first item.
 *
 * @note
 *  1. Beyond Integer.MAX_VALUE elements, the size method does not work.
 *  2. A queue's capacity cannot exceed Integer.MAX_VALUE. Any attempt to create a larger capacity results in failure
 *     due to arithmetic overflow.
 *  3. The capacity of the queues can change after it's created, but the capacity is limited by the amount of free
 *     memory on the machine. The constructors, ensureCapacity, add, and trimToSize will result in an OutOfMemoryError
 *     when free memory is exhausted.
 *
 * @author mlewis
 * @version Nov 9, 2019
 *********************************************************************************************************************/

public class ArrayQueue<E> implements Queue {
    // Invariant of the ArrayQueue class.
    // 1. For a nonempty queue, the items in the queue are stored in a circular array beginning at data[front] and
    //    continuing through data[rear]
    // 2. The instance variable size is a count of the number of items in this ArrayQueue.
    // 3. This ArrayQueue is a first-in/first-out data structure, so items are added at the rear and removed at the
    //    front.
    private int front;
    private int rear;
    private int size;
    private Object[] data;

    /**
     * public ArrayQueue()
     * Initialize an ArrayQueue with an initial capacity of 10 elements.
     * @postcondition
     *  This ArrayQueue has been initialized with an initial capacity of 10 elements.
     * @exception OutOfMemoryError
     *  Indicates insufficient memory for this ArrayQueue.
     */
     public ArrayQueue() {
        SET an initial capacity to 10
        SET front, rear, size to 0
        INIT a new array-based queue to the initial capacity
     }

     /**
      * public ArrayQueue(int capacity)
      * Initialize an ArrayQueue with the given initial capacity.
      * @postcondition
      *  This ArrayQueue has been initialized with the given initial capacity.
      * @exception IllegalArgumentException
      *  Indicates an invalid initial capacity. Initial capacity must be a positive integer.
      * @exception OutOfMemoryError
      *  Indicates insufficient memory for this ArrayQueue.
      */
      public ArrayQueue() {
        IF capacity is less than 0
            THEN throw an error
        ELSE
            SET front, rear, size to 0
            INIT a new array-based queue to the given capacity
      }

    /**
     * public void add(E item)
     * Mutator method that adds a new item to the rear of the Queue. The new item may be a null reference.
     * @param item
     *  The item to be added to the Queue.
     * @exception OutOfMemoryError
     *  Indicates insufficient memory for this item.
     */
    public void add(E item) {
        IF size equals length of the array
            THEN increase capacity
        ELSE IF size is 0
            THEN front and rear are at position 0
        ELSE
            FIND the rear of the array
        INSERT item at the rear of the bigger array
        INCREMENT size
    }

    /**
    * public void clear()
    * Mutator method that clears the queue and resets front, rear, and size to zero.
    * @postcondition
    *  The array is now empty and front, rear, and size are zero.
    */
    public void clear() {
        EMPTY the array
        SET front, rear, size to zero
    }

    /**
    * public void ensureCapacity(int capacity)
    * Change the current capacity of this array-based queue.
    * @param capacity
    *  The new capacity of the array-based queue.
    * @postcondition
    *  This queue's capacity has been increased to the given capacity. This queue's capacity may not need to increase
    *  the given capacity is less than this array-based queue's current capacity.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for the bigger array-based queue.
    */
    public void ensureCapacity(int capacity) {
        ADD local variables for a new array, the front, and rear

        IF length of array is greater than capacity
            THEN no change to capacity
        ELSE IF size of array is 0, then simply increase the capacity of the array-based queue
        ELSE IF front is less than rear
            INIT the bigger array to given capacity
            INSERT items into the bigger array from front to rear
        ELSE
            INIT the bigger array to the given capacity
            INSERT numbers from front to data.length - 1 into the bigger array
            INSERT numbers front rear to front - 1 into the bigger array
    }

    /**
    * public int getFront()
    * Accessor method that returns the front index of this array-based queue.
    * @return int
    *  The front index of this array-based queue.
    */
    public int getFront() {
        RETURN front;
    }

    /**
    * public int getCapacity()
    * Accessor method that returns the capacity of this array-based queue.
    * @return int
    *  The capacity of this array-based queue
    */
    public int getCapacity() {
        RETRN data.length
    }

    /**
    * public E getData()
    * Accessor method that returns a reference to the instance variable data, which is an array-based queue.
    * @return E
    *  A reference to the instance variable data, which is an array-based queue.
    */
    public ArrayQueue<E> getData() {
        RETURN (ArrayQueue) data;
    }

    /**
    * public int getRear()
    * Accessor method that returns the rear index of this array-based queue.
    * @return int
    *  The rear index of this array-based queue.
    */
    public int getRear() {
        RETURN rear;
    }

    /**
    * public int getItem(int index)
    * Accessor method that returns the item at the specified index.
    * @param index
    *  The target index.
    * @return int
    *  The item at the target index.
    */
    public int getItem(int index) {
        IF index is greater than size
            RETURN null
        RETURN item at the specified index
    }

    /**
    * public void setItem(int index, E item)
    * Mutator method that sets the value of the item at the specified index to the given item.
    * @param index
    *  The target index.
    * @param index
    *  The new item.
    * @postcondition
    *  The item at the specified index has been set to the specified item.
    */
    public void setItem(int index, E item) {
        IF index is greater than size
            RETURN
        SET data at index equal to item
    }

    /**
     * public boolean isEmpty()
     * Accessor method that determines whether or not this Queue is empty.
     * @return boolean
     *  True if this Queue is empty. Otherwise false.
     * @postcondition
     *  This Queue has not been modified.
     */
    public boolean isEmpty() {
        IF size equal 0
            RETURN true
        ELSE
            RETURN false
    }

    /**
    * private int nextIndex(int index)
    * Helper method that finds the next index when adding or removing from this array-based queue.
    * @param index
    *  The current front or rear index in this array-based queue.
    * @return int
    *  The next available index in this array-based queue.
    * @postcondition
    *  The return value is 0 if front equals the length of the array. Otherwise the return value is index + 1. Adding
    *  a new element to the nextIndex will not overwrite data because ensureCapacity() has guaranteed this.
    */
    private int nextIndex(int index) {
        IF index + 1 is greater than or equal to the length of this array-based queue
            THEN return 0 (array is circular)
        ELSE
            RETURN the incremented index
    }

    /**
    * public void print(ArrayQueue queue)
    * Prints every element contained in the specified queue. Note that front may be at a higher index than rear.
    * @postcondition
    *  The values in the specified queue have been written using System.out.println()
    */
    public void print(ArrayQueue queue) {
        FOR each element in queue
            PRINT element
    }
    }

    /**
     * public E remove()
     * Mutator method that removes the front item from this Queue.
     * @precondition
     *  This Queue is not empty.
     * @return E
     *  The front item from this Queue.
     * @postcondition
     *  The front item from this Queue has been removed and the next item (if there is one) is now the front item. Size
     *  has been decreased by one.
     */
    public E remove() {
        INIT local variable to hold front element

        IF isEmpty()
            THEN return null
        ELSE
            answer = front element
            front = front + 1 (or wrap to the 0th index)

        DECREASE size by one
        RETURN front item
    }

    /**
     * public int size()
     * Accessor method to determine the number of elements in this Queue.
     * @return int
     *  The number of items in this Queue.
     * @postcondition
     *  This Queue has not been modified.
     */
    public int size() {
        return size;
    }

    /**
    * public void trimToSize()
    * Mutator method to decrease the capacity of this array-based queue.
    * @postcondition
    *  The capacity of this array-based queue has been decreased to the size of the array. Note, the capacity may not
    *  be decreased if capacity and size are equivalent.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for the smaller array-based queue.
    */
    public void trimToSize() {
        Object[] smallerArray;

        IF size equals the length of this array-based queue
            return
        ELSE IF size is 0
            INIT smallerArray to the size of this array-based queue.
        ELSE IF front is smaller than rear
            INIT smallerArray to the size of this array-based queue.
            COPY data from this array based queue into the smaller array, starting from front to rear
        ELSE
            INIT smallerArray to the size of this array-based queue.
            COPY data from this array based queue into the smaller array from front to length of this array
            COPY data from this array based queue into the smaller array from 0 to rear

        SET this array based queue to the new smaller array based queue.
    }
}

