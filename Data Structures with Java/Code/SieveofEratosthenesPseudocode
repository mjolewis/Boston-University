/**********************************************************************************************************************
 * Pseudocode for programming project 2 of Data Structures with Java with Professor Berry
 *
 * @note
 *   1. Pseudocode for the Sieve of Eratosthenes
 *
 * @author mlewis
 * @version Nov 8, 2019
 *********************************************************************************************************************/

/*********************************************************************************************************************
* A user input class builds a GUI with a text input field and a return button. This class implements the
* ActionListener interface.
*
* @author mlewis
* @version Nov 8, 2019
*********************************************************************************************************************/

public class BuildGUI implements ActionListener {
    // Invariant of the UserInput.java class.
    //  1. The instance variable userInput stores the value entered by the user.
    int userInput;

    /**
    * public void constructGUI()
    * Constructs a GUI
    * @postcondition
    *  A GUID has been constructed.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for this GUI
    public void constructGUI() {
        INIT GUI frame
        INIT GUI panel
        INIT GUI button
        INIT GUI text field

        ADD ActionListener to button
        ADD panel to frame
        ADD button to frame

        SET frame size
        SET frame to visible
    }

    /**
    * private void actionPerformed(ActionEvent e)
    * Helper method that captures the users input.
    * @param e
    *  An action event listener object.
    * @postcondition
    *  The user has pressed the submit button and the input has been stored in the instance variable userInput. The
    *  test field has been cleared and focus has been restored to the text field.
    */
    private void actionPerformed(ActionEvent e) {
        SET userInput variable to text submitted by user
        CLEAR text field
        SET focus back to empty text field
    }
}

/**********************************************************************************************************************
* A calculate primes class uses the Sieve of Eratosthenes to calculate all the prime numbers up to some integer n. The
* technique was developed by a Greek mathematician and poet Eratosthenes who lived in the third century BC and it is
* implemented with an array-based queue.
*
* @note
*  1) Beyond Integer.MAX_VALUE elements, the array-based queue won't work properly.
*
* @author mlewis
* @version Nov 9, 2019
**********************************************************************************************************************/

public class CalculatePrimes {
    // Invariant of the CalculatePrimes class.
    //  1. The instance variable numbers is an array-based queue that has been initialized with consecutive integers 2
    //     through n inclusive if the value of n is greater than START_VALUE (+) MINIMUM_SIZE. Otherwise, the
    //     array-based queue has been initialized with 10 elements starting with the START_VALUE.
    //  2. The instance variable primes is an array-based queue that stores all the prime numbers calculated by the
    //     Sieve of Eratosthenes algorithm.
    //  3. The instance variable START_VALUE is the first element in the numbers array.
    //  4. The instance variable MINIMUM_SIZE guarantees the minimum size of the numbers array.
    private int[] numbers;
    private int[] primes;
    private int maxNumber;
    private static final int START_VALUE = 2;
    private static final int MINIMUM_SIZE = 10;

    /**
    * public CalculatePrimes()
    * Default constructor that initializes the numbers queue with 10 elements.
    * @postcondition
    *  The numbers queue has been initialized with 10 elements.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for this queue.
    */
    public CalculatePrimes() {
        INIT numbers array to minimum number of elements.
        INIT primes array to minimum number of elements.
    }

    /**
    * public CalculatePrimes(int maxNumber)
    * Overloaded constructor that initializes the numbers queue with consecutive integers 2 through n inclusive.
    * @postcondition
    *  The numbers queue has been initialized with consecutive integers 2 through n inclusive.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for this queue.
    */
    public CalculatePrimes(int maxNumber) {
        INIT default constructor
        INIT maxNumber to maxNumber
    }

    /**
    * private void addAll(int n)
    * Helper method that adds numbers 2 through n to the numbers queue. The numbers queue will automatically resize
    * if its capacity has been reached.
    * @param n
    *  The largest number to be added to the numbers queue. The numbers are added from 2 to n inclusive.
    * @precondition
    *  The user has entered a positive integer.
    * @postcondition
    *  The numbers 2 through n have been added to the numbers queue.
    */
    public void addAll(int n) {
        LOOP through the array
            IF size equals capacity
                THEN increase capacity
            ELSE
                ADD the numbers (first number is two) to the end of the numbers queue
    }


    /**
    * public ArrayQueue<E> findAllPrimes()
    * A method that finds all prime numbers from 2 to n inclusive. The method adds all prime numbers to an array-based
    * queue that automatically resizes if it's capacity has been reached.
    * @precondition
    *  The numbers 2 through n have been added to the numbers queue.
    * @return ArrayQueue<E>
    *  An array-based queue filled with all prime numbers from 2 to n inclusive.
    * @postcodition
    *  All prime numbers from 2 to n inclusive have been added to the primes queue.
    */
    public ArrayQueue<E> findAllPrimes() {
        DO
            Obtain the next prime p by removing the first value from the numbers queue.
            ADD p to the queue of primes
            LOOP over the numbers queue and eliminate numbers divisible b y p
        WHILE
            p < sqrt(n)

        ADD all remaining numbers from the numbers queue to the primes queue

        RETURN the prime queue
    }
}

/**********************************************************************************************************************
 * A ArrayQueue is a First-in/First-out data structure of ordered items such that items can be inserted at one end
 * (called the rear) and removed from the other end (called the front). The item at the front of the Queue is called
 * the first item.
 *
 * @note
 *  1. Beyond Integer.MAX_VALUE elements, the size method does not work.
 *  2. A queue's capacity cannot exceed Integer.MAX_VALUE. Any attempt to create a larger capacity results in failure
 *     due to arithmetic overflow.
 *  3. The capacity of the queues can change after it's created, but the capacity is limited by the amount of free
 *     memory on the machine. The constructors, ensureCapacity, add, and trimToSize will result in an OutOfMemoryError
 *     when free memory is exhausted.
 *
 * @author mlewis
 * @version Nov 9, 2019
 *********************************************************************************************************************/

public class ArrayQueue<E> implements Queue {
    // Invariant of the ArrayQueue class.
    // 1. For a nonempty queue, the items in the queue are stored in a circular array beginning at data[front] and
    //    continuing through data[rear]
    // 2. The instance variable size is a count of the number of items in this ArrayQueue.
    // 3. This ArrayQueue is a first-in/first-out data structure, so items are added at the rear and removed at the
    //    front.
    private int front;
    private int rear;
    private int size;
    private Object[] data;

    /**
     * public ArrayQueue()
     * Initialize an ArrayQueue with an initial capacity of 10 elements.
     * @postcondition
     *  This ArrayQueue has been initialized with an initial capacity of 10 elements.
     * @exception OutOfMemoryError
     *  Indicates insufficient memory for this ArrayQueue.
     */
     public ArrayQueue() {
        final int INITIAL_CAPACITY = 10;
        front = 0;
        rear = 0;
        size = 0;
        data = new Object[INITIAL_CAPACITY];
     }

    /**
     * public void add(E item)
     * Mutator method that adds a new item to the rear of the Queue. The new item may be a null reference.
     * @param item
     *  The item to be added to the Queue.
     * @exception OutOfMemoryError
     *  Indicates insufficient memory for this item.
     */
    public void add(E item) {
        IF size equals length of the array
            THEN increase capacity
        ELSE IF size is 0
            THEN front and rear are at position 0
        ELSE
            FIND the rear of the array
        INSERT item at the rear of the bigger array
        INCREMENT size
    }

    /**
    * public void ensureCapacity(int capacity)
    * Change the current capacity of this array-based queue.
    * @param capacity
    *  The new capacity of the array-based queue.
    * @postcondition
    *  This queue's capacity has been increased to the given capacity. This queue's capacity may not need to increase
    *  the given capacity is less than this array-based queue's current capacity.
    * @exception OutOfMemoryError
    *  Indicates insufficient memory for the bigger array-based queue.
    */
    public void ensureCapacity(int capacity) {
        ADD local variables for a new array, the front, and rear

        IF length of array is greater than capacity
            THEN no change to capacity
        ELSE IF size of array is 0, then simply increase the capacity of the array-based queue
        ELSE IF front is less than rear
            INIT the bigger array to given capacity
            INSERT items into the bigger array from front to rear
        ELSE
            INIT the bigger array to the given capacity
            INSERT numbers from front to data.length - 1 into the bigger array
            INSERT numbers front rear to front - 1 into the bigger array
    }

    /**
     * public boolean isEmpty()
     * Accessor method that determines whether or not this Queue is empty.
     * @return boolean
     *  True if this Queue is empty. Otherwise false.
     * @postcondition
     *  This Queue has not been modified.
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
    * private int nextIndex(int index)
    * Helper method that finds the next index when adding or removing from this array-based queue.
    * @param index
    *  The current front or rear index in this array-based queue.
    * @return int
    *  The next available index in this array-based queue.
    * @postcondition
    *  The return value is 0 if front equals the length of the array. Otherwise the return value is index + 1. Adding
    *  a new element to the nextIndex will not overwrite data because ensureCapacity() has guaranteed this.
    */
    private int nextIndex(int index) {
        if (++index >= data.length) {
            return 0;
        } else {
            return index;
        }
    }

    /**
     * public E remove()
     * Mutator method that removes the front item from this Queue.
     * @precondition
     *  This Queue is not empty.
     * @return E
     *  The front item from this Queue.
     * @postcondition
     *  The front item from this Queue has been removed and the next item (if there is one) is now the front item. Size
     *  has been decreased by one.
     */
    public E remove() {
        INIT local variable to hold front element

        IF isEmpty()
            THEN return null
        ELSE
            answer = front element
            front = front + 1 (or wrap to the 0th index)

        DECREASE size by one
        RETURN front item
    }

    /**
     * public int size()
     * Accessor method to determine the number of elements in this Queue.
     * @return int
     *  The number of items in this Queue.
     * @postcondition
     *  This Queue has not been modified.
     */
    public int size() {
        return size;
    }
}

